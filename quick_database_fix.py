#!/usr/bin/env python3

"""
Quick Database Fix Script - Python Version
Fixes the database connection issue shown in VPS screenshot
"""

import os
import sys
import subprocess
import json
from pathlib import Path

def print_status(msg):
    print(f"✅ {msg}")

def print_error(msg):
    print(f"❌ {msg}")

def print_warning(msg):
    print(f"⚠️  {msg}")

def print_step(msg):
    print(f"🔧 {msg}")

def check_database_connection(db_url):
    """Test database connection"""
    try:
        # Try to install required packages if not available
        try:
            import sqlalchemy
            import psycopg2
        except ImportError:
            print("Installing required packages...")
            subprocess.check_call([sys.executable, "-m", "pip", "install", "sqlalchemy", "psycopg2-binary"])
            import sqlalchemy
            import psycopg2
        
        from sqlalchemy import create_engine, text
        
        print(f"Testing connection to: {db_url[:50]}...")
        engine = create_engine(db_url)
        
        with engine.connect() as conn:
            result = conn.execute(text('SELECT 1'))
            row = result.fetchone()
            if row and row[0] == 1:
                return True, "Connection successful"
    except Exception as e:
        return False, str(e)
    
    return False, "Unknown error"

def main():
    print("🚨 QUICK DATABASE FIX - PYTHON VERSION")
    print("=" * 50)
    
    # 1. Get the correct Neon database URL
    print_step("1. Database URL Configuration")
    print("\nBerdasarkan screenshot error, aplikasi mencoba konek ke localhost:5432")
    print("Kita perlu menggunakan Neon database URL yang benar.")
    print()
    
    # Sample URL format
    print("Format URL Neon database:")
    print("postgresql://neondb_owner:PASSWORD@ep-billowing-sunset-xxxx.us-east-2.aws.neon.tech/neondb?sslmode=require")
    print()
    
    neon_url = input("Masukkan URL database Neon lengkap: ").strip()
    
    if not neon_url or not neon_url.startswith("postgresql://"):
        print_error("URL database tidak valid!")
        return 1
    
    # 2. Test database connection
    print_step("2. Testing database connection...")
    success, message = check_database_connection(neon_url)
    
    if success:
        print_status(f"Database connection successful: {message}")
    else:
        print_error(f"Database connection failed: {message}")
        print_warning("Periksa URL database dan network connectivity")
        return 1
    
    # 3. Find application directory
    print_step("3. Finding application directory...")
    
    possible_dirs = [
        Path.home() / "crypto-analysis-dashboard",
        Path("/root/crypto-analysis-dashboard"),
        Path("/opt/crypto-analysis-dashboard"),
        Path("/var/www/crypto-analysis-dashboard"),
        Path.cwd()
    ]
    
    app_dir = None
    for dir_path in possible_dirs:
        if dir_path.exists() and (dir_path / "main.py").exists():
            app_dir = dir_path
            break
    
    if not app_dir:
        print_error("Application directory not found!")
        app_dir = Path.home() / "crypto-analysis-dashboard"
        app_dir.mkdir(exist_ok=True)
        print_warning(f"Created directory: {app_dir}")
    
    print_status(f"Using application directory: {app_dir}")
    
    # 4. Create environment file
    print_step("4. Creating environment configuration...")
    
    env_file = app_dir / ".env.production"
    
    # Backup existing file if exists
    if env_file.exists():
        backup_file = env_file.with_suffix(f".env.production.backup.{int(__import__('time').time())}")
        env_file.rename(backup_file)
        print_status(f"Backed up existing file to: {backup_file}")
    
    # Create new environment file
    env_content = f"""# Production Environment - Database Fix
# Generated by quick_database_fix.py

# CRITICAL: Database Configuration
DATABASE_URL={neon_url}
SQLALCHEMY_DATABASE_URI={neon_url}

# Application Settings
FLASK_ENV=production
API_KEY_REQUIRED=true
DEBUG=False

# Security (REPLACE WITH YOUR ACTUAL KEYS!)
API_KEY=your-actual-api-key-here
SESSION_SECRET=your-super-secret-session-key

# AI Services (REPLACE WITH YOUR ACTUAL KEYS!)
OPENAI_API_KEY=sk-proj-your-openai-key-here

# Trading API (REPLACE WITH YOUR ACTUAL KEYS!)
OKX_API_KEY=your-okx-api-key
OKX_SECRET_KEY=your-okx-secret-key
OKX_PASSPHRASE=your-okx-passphrase

# Optional
TELEGRAM_BOT_TOKEN=your-telegram-token
TELEGRAM_CHAT_ID=your-chat-id
"""
    
    env_file.write_text(env_content)
    print_status(f"Environment file created: {env_file}")
    
    # 5. Create systemd service file
    print_step("5. Creating systemd service...")
    
    username = os.getenv("USER", "root")
    service_content = f"""[Unit]
Description=Cryptocurrency Trading API
After=network.target

[Service]
Type=notify
User={username}
Group={username}
WorkingDirectory={app_dir}
Environment=PATH={app_dir}/venv/bin
EnvironmentFile={env_file}
ExecStart={app_dir}/venv/bin/gunicorn --bind 0.0.0.0:5000 --workers 4 --worker-class gthread --threads 4 --timeout 60 main:app
ExecReload=/bin/kill -s HUP $MAINPID
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target
"""
    
    service_file = Path("/etc/systemd/system/cryptoapi.service")
    
    try:
        service_file.write_text(service_content)
        print_status("Systemd service file created")
    except PermissionError:
        print_warning("Need sudo access to create systemd service")
        temp_service = Path("/tmp/cryptoapi.service")
        temp_service.write_text(service_content)
        print(f"Service file created at: {temp_service}")
        print("Run this command as root:")
        print(f"sudo mv {temp_service} {service_file}")
    
    # 6. Create management scripts
    print_step("6. Creating management scripts...")
    
    scripts = {
        "start_service.sh": """#!/bin/bash
sudo systemctl daemon-reload
sudo systemctl enable cryptoapi.service
sudo systemctl start cryptoapi.service
sudo systemctl status cryptoapi.service
""",
        "check_health.sh": """#!/bin/bash
echo "=== Service Status ==="
sudo systemctl status cryptoapi.service --no-pager
echo ""
echo "=== Health Check ==="
curl -s http://localhost:5000/health | python3 -m json.tool 2>/dev/null || echo "Health check failed"
""",
        "view_logs.sh": """#!/bin/bash
echo "=== Recent Logs ==="
sudo journalctl -u cryptoapi.service -n 50 --no-pager
echo ""
echo "=== Follow Logs (Ctrl+C to exit) ==="
sudo journalctl -u cryptoapi.service -f
"""
    }
    
    for script_name, script_content in scripts.items():
        script_path = app_dir / script_name
        script_path.write_text(script_content)
        script_path.chmod(0o755)
        print_status(f"Created: {script_path}")
    
    # 7. Final instructions
    print()
    print("🎉 DATABASE FIX COMPLETE!")
    print("=" * 50)
    print()
    print_status("What was fixed:")
    print("  • Database URL now points to Neon instead of localhost")
    print("  • Environment file created with correct configuration")
    print("  • Systemd service configured")
    print("  • Management scripts created")
    print()
    print_warning("NEXT STEPS:")
    print(f"1. Edit environment file with your actual API keys:")
    print(f"   nano {env_file}")
    print()
    print("2. Start the service:")
    print(f"   cd {app_dir} && ./start_service.sh")
    print()
    print("3. Check health:")
    print(f"   ./check_health.sh")
    print()
    print("4. View logs:")
    print(f"   ./view_logs.sh")
    print()
    print_status("Your VPS should now connect to Neon database successfully!")
    
    return 0

if __name__ == "__main__":
    sys.exit(main())